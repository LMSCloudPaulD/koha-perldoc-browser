<html><head><title>Koha::SearchEngine::Elasticsearch</title>

<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üçÉ</text></svg>" />

<link rel="stylesheet" href="../../sub.css">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.42,
  using Pod::Simple::PullParser v3.42,
  under Perl v5.034000 at Sat Mar 18 18:18:06 2023 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#ACCESSORS'>ACCESSORS</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#get_elasticsearch'>get_elasticsearch</a>
    <li class='indexItem indexItem2'><a href='#get_elasticsearch_params'>get_elasticsearch_params</a>
    <li class='indexItem indexItem2'><a href='#get_elasticsearch_settings'>get_elasticsearch_settings</a>
    <li class='indexItem indexItem2'><a href='#get_elasticsearch_mappings'>get_elasticsearch_mappings</a>
    <li class='indexItem indexItem2'><a href='#raw_elasticsearch_mappings'>raw_elasticsearch_mappings</a>
    <li class='indexItem indexItem2'><a href='#_get_elasticsearch_field_config'>_get_elasticsearch_field_config</a>
    <li class='indexItem indexItem2'><a href='#_load_elasticsearch_mappings'>_load_elasticsearch_mappings</a>
    <li class='indexItem indexItem2'><a href='#_process_mappings(%24mappings%2C_%24data%2C_%24record_document%2C_%24meta)'>_process_mappings($mappings, $data, $record_document, $meta)</a>
    <li class='indexItem indexItem2'><a href='#marc_records_to_documents(%24marc_records)'>marc_records_to_documents($marc_records)</a>
    <li class='indexItem indexItem2'><a href='#_marc_to_array(%24record)'>_marc_to_array($record)</a>
    <li class='indexItem indexItem2'><a href='#_array_to_marc(%24data)'>_array_to_marc($data)</a>
    <li class='indexItem indexItem2'><a href='#_field_mappings(%24facet%2C_%24suggestible%2C_%24sort%2C_%24search%2C_%24target_name%2C_%24target_type%2C_%24range)'>_field_mappings($facet, $suggestible, $sort, $search, $target_name, $target_type, $range)</a>
    <li class='indexItem indexItem2'><a href='#_get_marc_mapping_rules'>_get_marc_mapping_rules</a>
    <li class='indexItem indexItem2'><a href='#_foreach_mapping'>_foreach_mapping</a>
    <li class='indexItem indexItem2'><a href='#process_error'>process_error</a>
    <li class='indexItem indexItem2'><a href='#_read_configuration'>_read_configuration</a>
    <li class='indexItem indexItem2'><a href='#get_facetable_fields'>get_facetable_fields</a>
    <li class='indexItem indexItem2'><a href='#clear_search_fields_cache'>clear_search_fields_cache</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Koha::SearchEngine::Elasticsearch - Base module for things using elasticsearch</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSORS"
>ACCESSORS</a></h1>

<dl>
<dt><a name="index"
>index</a></dt>

<dd>
<p>The name of the index to use,
generally &#39;biblios&#39; or &#39;authorities&#39;.</p>

<dt><a name="index_name"
>index_name</a></dt>

<dd>
<p>The Elasticsearch index name with Koha instance prefix.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_elasticsearch"
>get_elasticsearch</a></h2>

<pre>    my $elasticsearch_client = $self-&#62;get_elasticsearch();</pre>

<p>Returns a <code>Search::Elasticsearch</code> client. The client is cached on a <code>Koha::SearchEngine::ElasticSearch</code> instance level and will be reused if method is called multiple times.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_elasticsearch_params"
>get_elasticsearch_params</a></h2>

<pre>    my $params = $self-&#62;get_elasticsearch_params();</pre>

<p>This provides a hashref that contains the parameters for connecting to the ElasicSearch servers, in the form:</p>

<pre>    {
        &#39;nodes&#39; =&#62; [&#39;127.0.0.1:9200&#39;, &#39;anotherserver:9200&#39;],
        &#39;index_name&#39; =&#62; &#39;koha_instance_index&#39;,
    }</pre>

<p>This is configured by the following in the <code>config</code> block in koha-conf.xml:</p>

<pre>    &#60;elasticsearch&#62;
        &#60;server&#62;127.0.0.1:9200&#60;/server&#62;
        &#60;server&#62;anotherserver:9200&#60;/server&#62;
        &#60;index_name&#62;koha_instance&#60;/index_name&#62;
    &#60;/elasticsearch&#62;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_elasticsearch_settings"
>get_elasticsearch_settings</a></h2>

<pre>    my $settings = $self-&#62;get_elasticsearch_settings();</pre>

<p>This provides the settings provided to Elasticsearch when an index is created. These can do things like define tokenization methods.</p>

<p>A hashref containing the settings is returned.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_elasticsearch_mappings"
>get_elasticsearch_mappings</a></h2>

<pre>    my $mappings = $self-&#62;get_elasticsearch_mappings();</pre>

<p>This provides the mappings that get passed to Elasticsearch when an index is created.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="raw_elasticsearch_mappings"
>raw_elasticsearch_mappings</a></h2>

<p>Return elasticsearch mapping as it is in database. marc_type: marc21|unimarc</p>

<p>$raw_mappings = raw_elasticsearch_mappings( $marc_type )</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_get_elasticsearch_field_config"
>_get_elasticsearch_field_config</a></h2>

<p>Get the Elasticsearch field config for the given purpose and data type.</p>

<p>$mapping = _get_elasticsearch_field_config(&#39;search&#39;, &#39;text&#39;);</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_load_elasticsearch_mappings"
>_load_elasticsearch_mappings</a></h2>

<p>Load Elasticsearch mappings in the format of mappings.yaml.</p>

<p>$indexes = _load_elasticsearch_mappings();</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_process_mappings($mappings,_$data,_$record_document,_$meta)"
>_process_mappings($mappings, $data, $record_document, $meta)</a></h2>

<pre>    $self-&#62;_process_mappings($mappings, $marc_field_data, $record_document, 0)</pre>

<p>Process all <code>$mappings</code> targets operating on a specific MARC field <code>$data</code>. Since we group all mappings by MARC field targets <code>$mappings</code> will contain all targets for <code>$data</code> and thus we need to fetch the MARC field only once. <code>$mappings</code> will be applied to <code>$record_document</code> and new field values added. The method has no return value.</p>

<dl>
<dt><a name="$mappings"
><code>$mappings</code></a></dt>

<dd>
<p>Arrayref of mappings containing arrayrefs in the format [<code>$target</code>, <code>$options</code>] where <code>$target</code> is the name of the target field and <code>$options</code> is a hashref containing processing directives for this particular mapping.</p>

<dt><a name="$data"
><code>$data</code></a></dt>

<dd>
<p>The source data from a MARC record field.</p>

<dt><a name="$record_document"
><code>$record_document</code></a></dt>

<dd>
<p>Hashref representing the Elasticsearch document on which mappings should be applied.</p>

<dt><a name="$meta"
><code>$meta</code></a></dt>

<dd>
<p>A hashref containing metadata useful for enforcing per mapping rules. For example for providing extra context for mapping options, or treating mapping targets differently depending on type (sort, search, facet etc). Combining this metadata with the mapping options and metadata allows us to mutate the data per mapping, or even replace it with other data retrieved from the metadata context.</p>

<p>Current properties are:</p>

<p><code>altscript</code>: A boolean value indicating whether an alternate script presentation is being processed.</p>

<p><code>data_source</code>: The source of the $&#60;data&#62; argument. Possible values are: &#39;leader&#39;, &#39;control_field&#39;, &#39;subfield&#39; or &#39;subfields_group&#39;.</p>

<p><code>code</code>: The code of the subfield <code>$data</code> was retrieved, if <code>data_source</code> is &#39;subfield&#39;.</p>

<p><code>codes</code>: Subfield codes of the subfields group from which <code>$data</code> was retrieved, if <code>data_source</code> is &#39;subfields_group&#39;.</p>

<p><code>field</code>: The original <code>MARC::Record</code> object.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="marc_records_to_documents($marc_records)"
>marc_records_to_documents($marc_records)</a></h2>

<pre>    my $record_documents = $self-&#62;marc_records_to_documents($marc_records);</pre>

<p>Using mappings stored in database convert <code>$marc_records</code> to Elasticsearch documents.</p>

<p>Returns array of hash references, representing Elasticsearch documents, acceptable as body payload in <code>Search::Elasticsearch</code> requests.</p>

<dl>
<dt><a name="$marc_documents"
><code>$marc_documents</code></a></dt>

<dd>
<p>Reference to array of <code>MARC::Record</code> objects to be converted to Elasticsearch documents.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_marc_to_array($record)"
>_marc_to_array($record)</a></h2>

<pre>    my @fields = _marc_to_array($record)</pre>

<p>Convert a MARC::Record to an array modeled after MARC-in-JSON (see https://github.com/marc4j/marc4j/wiki/MARC-in-JSON-Description)</p>

<dl>
<dt><a name="$record"
><code>$record</code></a></dt>

<dd>
<p>A MARC::Record object</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_array_to_marc($data)"
>_array_to_marc($data)</a></h2>

<pre>    my $record = _array_to_marc($data)</pre>

<p>Convert an array modeled after MARC-in-JSON to a MARC::Record</p>

<dl>
<dt><a name="$data"
><code>$data</code></a></dt>

<dd>
<p>An array modeled after MARC-in-JSON (see https://github.com/marc4j/marc4j/wiki/MARC-in-JSON-Description)</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_field_mappings($facet,_$suggestible,_$sort,_$search,_$target_name,_$target_type,_$range)"
>_field_mappings($facet, $suggestible, $sort, $search, $target_name, $target_type, $range)</a></h2>

<pre>    my @mappings = _field_mappings($facet, $suggestible, $sort, $search, $target_name, $target_type, $range)</pre>

<p>Get mappings, an internal data structure later used by <a href="#_process_mappings(%24mappings%2C_%24data%2C_%24record_document%2C_%24meta)" class="podlinkpod"
>&#34;_process_mappings($mappings, $data, $record_document, $meta)&#34;</a> to process MARC target data for a MARC mapping.</p>

<p>The returned <code>$mappings</code> is not to to be confused with mappings provided by <code>_foreach_mapping</code>, rather this sub accepts properties from a mapping as provided by <code>_foreach_mapping</code> and expands it to this internal data structure. In the caller context (<code>_get_marc_mapping_rules</code>) the returned <code>@mappings</code> is then applied to each MARC target (leader, control field data, subfield or joined subfields) and integrated into the mapping rules data structure used in <code>marc_records_to_documents</code> to transform MARC records into Elasticsearch documents.</p>

<dl>
<dt><a name="$facet"
><code>$facet</code></a></dt>

<dd>
<p>Boolean indicating whether to create a facet field for this mapping.</p>

<dt><a name="$suggestible"
><code>$suggestible</code></a></dt>

<dd>
<p>Boolean indicating whether to create a suggestion field for this mapping.</p>

<dt><a name="$sort"
><code>$sort</code></a></dt>

<dd>
<p>Boolean indicating whether to create a sort field for this mapping.</p>

<dt><a name="$search"
><code>$search</code></a></dt>

<dd>
<p>Boolean indicating whether to create a search field for this mapping.</p>

<dt><a name="$target_name"
><code>$target_name</code></a></dt>

<dd>
<p>Elasticsearch document target field name.</p>

<dt><a name="$target_type"
><code>$target_type</code></a></dt>

<dd>
<p>Elasticsearch document target field type.</p>

<dt><a name="$range"
><code>$range</code></a></dt>

<dd>
<p>An optional range as a string in the format &#34;&#60;START&#62;-&#60;END&#62;&#34; or &#34;&#60;START&#62;&#34;, where &#34;&#60;START&#62;&#34; and &#34;&#60;END&#62;&#34; are integers specifying a range that will be used for extracting a substring from MARC data as Elasticsearch field target value.</p>

<p>The first character position is &#34;0&#34;, and the range is inclusive, so &#34;0-2&#34; means the first three characters of MARC data.</p>

<p>If only &#34;&#60;START&#62;&#34; is provided only one character at position &#34;&#60;START&#62;&#34; will be extracted.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_get_marc_mapping_rules"
>_get_marc_mapping_rules</a></h2>

<pre>    my $mapping_rules = $self-&#62;_get_marc_mapping_rules()</pre>

<p>Generates rules from mappings stored in database for MARC records to Elasticsearch JSON document conversion.</p>

<p>Since field retrieval is slow in <code>MARC::Records</code> (all fields are itereted through for each call to <code>MARC::Record</code>-&#62;field) we create an optimized structure of mapping rules keyed by MARC field tags holding all the mapping rules for that particular tag.</p>

<p>We can then iterate through all MARC fields for each record and apply all relevant rules once per fields instead of retreiving fields multiple times for each mapping rule which is terribly slow.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_foreach_mapping"
>_foreach_mapping</a></h2>

<pre>    $self-&#62;_foreach_mapping(
        sub {
            my ( $name, $type, $facet, $suggestible, $sort, $marc_type,
                $marc_field )
              = @_;
            return unless $marc_type eq &#39;marc21&#39;;
            print &#34;Data comes from: &#34; . $marc_field . &#34;\n&#34;;
        }
    );</pre>

<p>This allows you to apply a function to each entry in the elasticsearch mappings table, in order to build the mappings for whatever is needed.</p>

<p>In the provided function, the files are:</p>

<dl>
<dt><a name="$name"
><code>$name</code></a></dt>

<dd>
<p>The field name for elasticsearch (corresponds to the &#39;mapping&#39; column in the database.</p>

<dt><a name="$type"
><code>$type</code></a></dt>

<dd>
<p>The type for this value, e.g. &#39;string&#39;.</p>

<dt><a name="$facet"
><code>$facet</code></a></dt>

<dd>
<p>True if this value should be facetised. This only really makes sense if the field is understood by the facet processing code anyway.</p>

<dt><a name="$sort"
><code>$sort</code></a></dt>

<dd>
<p>True if this is a field that a) needs special sort handling, and b) if it should be sorted on. False if a) but not b). Undef if not a). This allows, for example, author to be sorted on but not everything marked with &#34;author&#34; to be included in that sort.</p>

<dt><a name="$marc_type"
><code>$marc_type</code></a></dt>

<dd>
<p>A string that indicates the MARC type that this mapping is for, e.g. &#39;marc21&#39;, &#39;unimarc&#39;.</p>

<dt><a name="$marc_field"
><code>$marc_field</code></a></dt>

<dd>
<p>A string that describes the MARC field that contains the data to extract.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="process_error"
>process_error</a></h2>

<pre>    die process_error($@);</pre>

<p>This parses an Elasticsearch error message and produces a human-readable result from it. This result is probably missing all the useful information that you might want in diagnosing an issue, so the warning is also logged.</p>

<p>Note that currently the resulting message is not internationalised. This will happen eventually by some method or other.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_read_configuration"
>_read_configuration</a></h2>

<pre>    my $conf = _read_configuration();</pre>

<p>Reads the <i>configuration file</i> and returns a hash structure with the configuration information. It raises an exception if mandatory entries are missing.</p>

<p>The hashref structure has the following form:</p>

<pre>    {
        &#39;nodes&#39; =&#62; [&#39;127.0.0.1:9200&#39;, &#39;anotherserver:9200&#39;],
        &#39;index_name&#39; =&#62; &#39;koha_instance&#39;,
    }</pre>

<p>This is configured by the following in the <code>config</code> block in koha-conf.xml:</p>

<pre>    &#60;elasticsearch&#62;
        &#60;server&#62;127.0.0.1:9200&#60;/server&#62;
        &#60;server&#62;anotherserver:9200&#60;/server&#62;
        &#60;index_name&#62;koha_instance&#60;/index_name&#62;
    &#60;/elasticsearch&#62;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_facetable_fields"
>get_facetable_fields</a></h2>

<p>my @facetable_fields = Koha::SearchEngine::Elasticsearch-&#62;get_facetable_fields();</p>

<p>Returns the list of Koha::SearchFields marked to be faceted in the ES configuration</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="clear_search_fields_cache"
>clear_search_fields_cache</a></h2>

<p>Koha::SearchEngine::Elasticsearch-&#62;clear_search_fields_cache();</p>

<p>Clear cached values for ES search fields</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<dl>
<dt><a name="Chris_Cormack_&#60;chrisc@catalyst.net.nz&#62;"
>Chris Cormack <code>&#60;chrisc@catalyst.net.nz&#62;</code></a></dt>

<dd>
<dt><a name="Robin_Sheat_&#60;robin@catalyst.net.nz&#62;"
>Robin Sheat <code>&#60;robin@catalyst.net.nz&#62;</code></a></dt>

<dd>
<dt><a name="Jonathan_Druart_&#60;jonathan.druart@bugs.koha-community.org&#62;"
>Jonathan Druart <code>&#60;jonathan.druart@bugs.koha-community.org&#62;</code></a></dt>
</dl>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
