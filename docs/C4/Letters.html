<html><head><title>C4::Letters</title>

<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üçÉ</text></svg>" />

<link rel="stylesheet" href="../sub.css">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.42,
  using Pod::Simple::PullParser v3.42,
  under Perl v5.034000 at Sat Sep 30 12:13:28 2023 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#GetLetters(%5B%24module%5D)'>GetLetters([$module])</a>
    <li class='indexItem indexItem2'><a href='#GetLetterTemplates'>GetLetterTemplates</a>
    <li class='indexItem indexItem2'><a href='#GetLettersAvailableForALibrary'>GetLettersAvailableForALibrary</a>
    <li class='indexItem indexItem2'><a href='#DelLetter'>DelLetter</a>
    <li class='indexItem indexItem2'><a href='#SendAlerts'>SendAlerts</a>
    <li class='indexItem indexItem2'><a href='#GetPreparedLetter(_%25params_)'>GetPreparedLetter( %params )</a>
    <li class='indexItem indexItem2'><a href='#_parseletter(%24letter%2C_%24table%2C_%24values)'>_parseletter($letter, $table, $values)</a>
    <li class='indexItem indexItem2'><a href='#EnqueueLetter'>EnqueueLetter</a>
    <li class='indexItem indexItem2'><a href='#SendQueuedMessages_(%5B%24hashref%5D)'>SendQueuedMessages ([$hashref])</a>
    <li class='indexItem indexItem2'><a href='#GetRSSMessages'>GetRSSMessages</a>
    <li class='indexItem indexItem2'><a href='#GetPrintMessages'>GetPrintMessages</a>
    <li class='indexItem indexItem2'><a href='#GetQueuedMessages_(%5B%24hashref%5D)'>GetQueuedMessages ([$hashref])</a>
    <li class='indexItem indexItem2'><a href='#GetMessageTransportTypes'>GetMessageTransportTypes</a>
    <li class='indexItem indexItem2'><a href='#GetMessage'>GetMessage</a>
    <li class='indexItem indexItem2'><a href='#ResendMessage'>ResendMessage</a>
    <li class='indexItem indexItem2'><a href='#_add_attachements'>_add_attachements</a>
    <li class='indexItem indexItem2'><a href='#_get_unsent_messages'>_get_unsent_messages</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#add_tt_filters'>add_tt_filters</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#get_item_content'>get_item_content</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>C4::Letters - Give functions for Letters management</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use C4::Letters;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<pre>  &#34;Letters&#34; is the tool used in Koha to manage informations sent to the patrons and/or the library. This include some cron jobs like
  late issues, as well as other tasks like sending a mail to users that have subscribed to a &#34;serial issue alert&#34; (= being warned every time a new issue has arrived at the library)

  Letters are managed through &#34;alerts&#34; sent by Koha on some events. All &#34;alert&#34; related functions are in this module too.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetLetters([$module])"
>GetLetters([$module])</a></h2>

<pre>  $letters = &#38;GetLetters($module);
  returns informations about letters.
  if needed, $module filters for letters given module

  DEPRECATED - You must use Koha::Notice::Templates instead
  The group by clause is confusing and can lead to issues</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetLetterTemplates"
>GetLetterTemplates</a></h2>

<pre>    my $letter_templates = GetLetterTemplates(
        {
            module =&#62; &#39;circulation&#39;,
            code =&#62; &#39;my code&#39;,
            branchcode =&#62; &#39;CPL&#39;, # &#39;&#39; for default,
        }
    );

    Return a hashref of letter templates.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetLettersAvailableForALibrary"
>GetLettersAvailableForALibrary</a></h2>

<pre>    my $letters = GetLettersAvailableForALibrary(
        {
            branchcode =&#62; &#39;CPL&#39;, # &#39;&#39; for default
            module =&#62; &#39;circulation&#39;,
        }
    );

    Return an arrayref of letters, sorted by name.
    If a specific letter exist for the given branchcode, it will be retrieve.
    Otherwise the default letter will be.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DelLetter"
>DelLetter</a></h2>

<pre>    DelLetter(
        {
            branchcode =&#62; &#39;CPL&#39;,
            module =&#62; &#39;circulation&#39;,
            code =&#62; &#39;my code&#39;,
            [ mtt =&#62; &#39;email&#39;, ]
        }
    );

    Delete the letter. The mtt parameter is facultative.
    If not given, all templates mathing the other parameters will be removed.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="SendAlerts"
>SendAlerts</a></h2>

<pre>    my $err = &#38;SendAlerts($type, $externalid, $letter_code);

    Parameters:
      - $type : the type of alert
      - $externalid : the id of the &#34;object&#34; to query
      - $letter_code : the notice template to use

    C&#60;&#38;SendAlerts&#62; sends an email notice directly to a patron or a vendor.

    Currently it supports ($type):
      - claim serial issues (claimissues)
      - claim acquisition orders (claimacquisition)
      - send acquisition orders to the vendor (orderacquisition)
      - notify patrons about newly received serial issues (issue)
      - notify patrons when their account is created (members)

    Returns undef or { error =&#62; &#39;message } on failure.
    Returns true on success.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetPreparedLetter(_%params_)"
>GetPreparedLetter( %params )</a></h2>

<pre>    %params hash:
      module =&#62; letter module, mandatory
      letter_code =&#62; letter code, mandatory
      branchcode =&#62; for letter selection, if missing default system letter taken
      tables =&#62; a hashref with table names as keys. Values are either:
        - a scalar - primary key value
        - an arrayref - primary key values
        - a hashref - full record
      substitute =&#62; custom substitution key/value pairs
      repeat =&#62; records to be substituted on consecutive lines:
        - an arrayref - tries to guess what needs substituting by
          taking remaining &#60;&#60; &#62;&#62; tokensr; not recommended
        - a hashref token =&#62; @tables - replaces &#60;token&#62; &#60;&#60; &#62;&#62; &#60;&#60; &#62;&#62; &#60;/token&#62;
          subtemplate for each @tables row; table is a hashref as above
      want_librarian =&#62; boolean,  if set to true triggers librarian details
        substitution from the userenv
    Return value:
      letter fields hashref (title &#38; content useful)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_parseletter($letter,_$table,_$values)"
>_parseletter($letter, $table, $values)</a></h2>

<pre>    parameters :
    - $letter : a hash to letter fields (title &#38; content useful)
    - $table : the Koha table to parse.
    - $values_in : table record hashref
    parse all fields from a table, and replace values in title &#38; content with the appropriate value
    (not exported sub, used only internally)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="EnqueueLetter"
>EnqueueLetter</a></h2>

<pre>  my $success = EnqueueLetter( { letter =&#62; $letter, 
        borrowernumber =&#62; &#39;12&#39;, message_transport_type =&#62; &#39;email&#39; } )</pre>

<p>Places a letter in the message_queue database table, which will eventually get processed (sent) by the process_message_queue.pl cronjob when it calls SendQueuedMessages.</p>

<p>Return message_id on success</p>

<p>Parameters * letter - required; A letter hashref as returned from GetPreparedLetter * message_transport_type - required; One of the available mtts * borrowernumber - optional if &#39;to_address&#39; is passed; The borrowernumber of the patron we enqueuing the notice for * to_address - optional if &#39;borrowernumber&#39; is passed; The destination email address for the notice (defaults to patron-&#62;notice_email_address) * from_address - optional; The from address for the notice, defaults to patron-&#62;library-&#62;from_email_address * reply_address - optional; The reply address for the notice, defaults to patron-&#62;library-&#62;reply_to</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="SendQueuedMessages_([$hashref])"
>SendQueuedMessages ([$hashref])</a></h2>

<pre>    my $sent = SendQueuedMessages({
        message_id =&#62; $id,
        borrowernumber =&#62; $who_letter_is_for,
        letter_code =&#62; $letter_code, # can be scalar or arrayref
        type =&#62; $type, # can be scalar or arrayref
        limit =&#62; 50,
        verbose =&#62; 1,
        where =&#62; $where,
    });</pre>

<p>Sends &#39;pending&#39; messages from the queue, based on parameters.</p>

<p>The (optional) message_id, borrowernumber, letter_code, type and where parameter are used to select which pending messages will be processed. The limit parameter determines the volume of results, i.e. sent messages.</p>

<p>The optional verbose parameter can be used to generate debugging output.</p>

<p>Returns number of messages sent.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetRSSMessages"
>GetRSSMessages</a></h2>

<pre>  my $message_list = GetRSSMessages( { limit =&#62; 10, borrowernumber =&#62; &#39;14&#39; } )</pre>

<p>returns a listref of all queued RSS messages for a particular person.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetPrintMessages"
>GetPrintMessages</a></h2>

<pre>  my $message_list = GetPrintMessages( { borrowernumber =&#62; $borrowernumber } )</pre>

<p>Returns a arrayref of all queued print messages (optionally, for a particular person).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetQueuedMessages_([$hashref])"
>GetQueuedMessages ([$hashref])</a></h2>

<pre>  my $messages = GetQueuedMessage( { borrowernumber =&#62; &#39;123&#39;, limit =&#62; 20 } );</pre>

<p>Fetches a list of messages from the message queue optionally filtered by borrowernumber and limited to specified limit.</p>

<p>Return is an arrayref of hashes, each has represents a message in the message queue.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetMessageTransportTypes"
>GetMessageTransportTypes</a></h2>

<pre>  my @mtt = GetMessageTransportTypes();

  returns an arrayref of transport types</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GetMessage"
>GetMessage</a></h2>

<pre>    my $message = C4::Letters::Message($message_id);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ResendMessage"
>ResendMessage</a></h2>

<pre>  Attempt to resend a message which has failed previously.

  my $has_been_resent = C4::Letters::ResendMessage($message_id);

  Updates the message to &#39;pending&#39; status so that
  it will be resent later on.

  returns 1 on success, 0 on failure, undef if no message was found</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_add_attachements"
>_add_attachements</a></h2>

<pre>  _add_attachments({ letter =&#62; $letter, attachments =&#62; $attachments });

  named parameters:
  letter - the standard letter hashref
  attachments - listref of attachments. each attachment is a hashref of:
    type - the mime type, like &#39;text/plain&#39;
    content - the actual attachment
    filename - the name of the attachment.

  returns your letter object, with the content updated.
  This routine picks the I&#60;content&#62; of I&#60;letter&#62; and generates a MIME
  email, attaching the passed I&#60;attachments&#62; using Koha::Email. The
  content is replaced by the string representation of the MIME object,
  and the content-type is updated for later handling.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_get_unsent_messages"
>_get_unsent_messages</a></h2>

<pre>  This function&#39;s parameter hash reference takes the following
  optional named parameters:
   message_transport_type: method of message sending (e.g. email, sms, etc.)
                           Can be a single string, or an arrayref of strings
   borrowernumber        : who the message is to be sent
   letter_code           : type of message being sent (e.g. PASSWORD_RESET)
                           Can be a single string, or an arrayref of strings
   message_id            : the message_id of the message. In that case the sub will return only 1 result
   limit                 : maximum number of messages to send

  This function returns an array of matching hash referenced rows from
  message_queue with some borrower information added.</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="add_tt_filters"
>add_tt_filters</a></h3>

<p>$content = add_tt_filters( $content );</p>

<p>Add TT filters to some specific fields if needed.</p>

<p>For now we only add the Remove_MARC_punctuation TT filter to biblio and biblioitem fields</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_item_content"
>get_item_content</a></h2>

<pre>    my $item = Koha::Items-&#62;find(...)-&#62;unblessed;
    my @item_content_fields = qw( date_due title barcode author itemnumber );
    my $item_content = C4::Letters::get_item_content({
                             item =&#62; $item,
                             item_content_fields =&#62; \@item_content_fields
                       });</pre>

<p>This function generates a tab-separated list of values for the passed item. Dates are formatted following the current setup.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
