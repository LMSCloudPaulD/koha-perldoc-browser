<html><head><title>Koha::Cache</title>

<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üçÉ</text></svg>" />

<link rel="stylesheet" href="../sub.css">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.42,
  using Pod::Simple::PullParser v3.42,
  under Perl v5.034000 at Mon Jan  9 12:29:35 2023 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <li class='indexItem indexItem2'><a href='#is_cache_active'>is_cache_active</a>
    <li class='indexItem indexItem2'><a href='#set_in_cache'>set_in_cache</a>
    <li class='indexItem indexItem2'><a href='#get_from_cache'>get_from_cache</a>
    <li class='indexItem indexItem2'><a href='#clear_from_cache'>clear_from_cache</a>
    <li class='indexItem indexItem2'><a href='#flush_all'>flush_all</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TIED_INTERFACE'>TIED INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#create_scalar'>create_scalar</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#EXPORT'>EXPORT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Koha::Cache - Handling caching of html and Objects for Koha</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Koha::Cache;
  my $cache = Koha::Cache-&#62;new({cache_type =&#62; $cache_type, %params});

  # see also Koha::Caches-&#62;get_instance;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Koha caching routines. This class provides two interfaces for cache access. The first, traditional OO interface provides the following functions:</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>Create a new Koha::Cache object. This is required for all cache-related functionality.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_cache_active"
>is_cache_active</a></h2>

<p>Routine that checks whether or not a default caching method is active on this object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_in_cache"
>set_in_cache</a></h2>

<pre>    $cache-&#62;set_in_cache($key, $value, [$options]);</pre>

<p>Save a value to the specified key in the cache. A hashref of options may be specified.</p>

<p>The possible options are:</p>

<dl>
<dt><a name="expiry"
>expiry</a></dt>

<dd>
<p>Expiry time of this cached entry in seconds.</p>

<dt><a name="cache"
>cache</a></dt>

<dd>
<p>The cache object to use if you want to provide your own. It should be an instance of <code>Cache::*</code> and follow the same interface as <a href="../Cache/Memcache.html" class="podlinkpod"
>Cache::Memcache</a>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_from_cache"
>get_from_cache</a></h2>

<pre>    my $value = $cache-&#62;get_from_cache($key, [ $options ]);</pre>

<p>Retrieve the value stored under the specified key in the cache.</p>

<p>The possible options are:</p>

<dl>
<dt><a name="unsafe"
>unsafe</a></dt>

<dd>
<p>If set, this will avoid performing a deep copy of the item. This means that it won&#39;t be safe if something later modifies the result of the function. It should be used with caution, and could save processing time in some situations where is safe to use it. Make sure you know what you are doing!</p>

<dt><a name="cache"
>cache</a></dt>

<dd>
<p>The cache object to use if you want to provide your own. It should be an instance of <code>Cache::*</code> and follow the same interface as <a href="../Cache/Memcache.html" class="podlinkpod"
>Cache::Memcache</a>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="clear_from_cache"
>clear_from_cache</a></h2>

<pre>    $cache-&#62;clear_from_cache($key);</pre>

<p>Remove the value identified by the specified key from the default cache.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="flush_all"
>flush_all</a></h2>

<pre>    $cache-&#62;flush_all();</pre>

<p>Clear the entire default cache.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TIED_INTERFACE"
>TIED INTERFACE</a></h1>

<p>Koha::Cache also provides a tied interface which enables users to provide a constructor closure and (after creation) treat cached data like normal reference variables and rely on the cache Just Working and getting updated when it expires, etc.</p>

<pre>    my $cache = Koha::Cache-&#62;new();
    my $data = &#39;whatever&#39;;
    my $scalar = Koha::Cache-&#62;create_scalar(
        {
            &#39;key&#39;         =&#62; &#39;whatever&#39;,
            &#39;timeout&#39;     =&#62; 2,
            &#39;constructor&#39; =&#62; sub { return $data; },
        }
    );
    print &#34;$$scalar\n&#34;; # Prints &#34;whatever&#34;
    $data = &#39;somethingelse&#39;;
    print &#34;$$scalar\n&#34;; # Prints &#34;whatever&#34; because it is cached
    sleep 2; # Wait until the cache entry has expired
    print &#34;$$scalar\n&#34;; # Prints &#34;somethingelse&#34;

    my $hash = Koha::Cache-&#62;create_hash(
        {
            &#39;key&#39;         =&#62; &#39;whatever&#39;,
            &#39;timeout&#39;     =&#62; 2,
            &#39;constructor&#39; =&#62; sub { return $data; },
        }
    );
    print &#34;$$variable\n&#34;; # Prints &#34;whatever&#34;</pre>

<p>The gotcha with this interface, of course, is that the variable returned by create_scalar and create_hash is a <i>reference</i> to a tied variable and not a tied variable itself.</p>

<p>The tied variable is configured by means of a hashref passed in to the create_scalar and create_hash methods. The following parameters are supported:</p>

<dl>
<dt><a name="key"
><i>key</i></a></dt>

<dd>
<p>Required. The key to use for identifying the variable in the cache.</p>

<dt><a name="constructor"
><i>constructor</i></a></dt>

<dd>
<p>Required. A closure (or reference to a function) that will return the value that needs to be stored in the cache.</p>

<dt><a name="preload"
><i>preload</i></a></dt>

<dd>
<p>Optional. A closure (or reference to a function) that gets run to initialize the cache when creating the tied variable.</p>

<dt><a name="arguments"
><i>arguments</i></a></dt>

<dd>
<p>Optional. Array reference with the arguments that should be passed to the constructor function.</p>

<dt><a name="timeout"
><i>timeout</i></a></dt>

<dd>
<p>Optional. The cache timeout in seconds for the variable. Defaults to 600 (ten minutes).</p>

<dt><a name="cache_type"
><i>cache_type</i></a></dt>

<dd>
<p>Optional. Which type of cache to use for the variable. Defaults to whatever is set in the environment variable CACHING_SYSTEM. If set to &#39;null&#39;, disables caching for the tied variable.</p>

<dt><a name="allowupdate"
><i>allowupdate</i></a></dt>

<dd>
<p>Optional. Boolean flag to allow the variable to be updated directly. When this is set and the variable is used as an l-value, the cache will be updated immediately with the new value. Using this is probably a bad idea on a multi-threaded system. When <i>allowupdate</i> is not set to true, using the tied variable as an l-value will have no effect.</p>

<dt><a name="destructor"
><i>destructor</i></a></dt>

<dd>
<p>Optional. A closure (or reference to a function) that should be called when the tied variable is destroyed.</p>

<dt><a name="unset"
><i>unset</i></a></dt>

<dd>
<p>Optional. Boolean flag to tell the object to remove the variable from the cache when it is destroyed or goes out of scope.</p>

<dt><a name="inprocess"
><i>inprocess</i></a></dt>

<dd>
<p>Optional. Boolean flag to tell the object not to refresh the variable from the cache every time the value is desired, but rather only when the <i>local</i> copy of the variable is older than the timeout.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_scalar"
>create_scalar</a></h2>

<pre>    my $scalar = Koha::Cache-&#62;create_scalar(\%params);</pre>

<p>Create scalar tied to the cache.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXPORT"
>EXPORT</a></h1>

<p>None by default.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Koha::Cache::Object</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Chris Cormack, &#60;chris@bigballofwax.co.nz&#62; Paul Poulain, &#60;paul.poulain@biblibre.com&#62; Jared Camins-Esakov, &#60;jcamins@cpbibliography.com&#62;</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
